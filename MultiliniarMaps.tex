\chapter{Multilinear Maps and Graded Encoding Systems}

In this chapter, multilinear maps are defined and also, the particular case of bilinear maps is discussed, along with results concerning self-bilinear applications. Thereafter, \textit{Graded Encoding Schemes} are defined, as an approximate to multilinear maps. \\

\textit{Observation:} Regarding the multilinear applications and Graded Encoding Systems schemes, and also for the lattice-based candidate designed in \cite{GGH13}, the paper encompasses one subsection of efficient procedures, and another one of hardness assumptions. The reader should be aware of this detail and realize the analogy and differences of the mentioned schemes.


\section{Bilinear Maps}
As stated before, bilinear maps are a specific case of multilinear maps. They proved to be a highly useful tool in cryptography, with many applications, such as: tripartite protocol \cite{Jou00}, identity based encryption \cite{BoF01} and Attribute-based encryption scheme for monotone boolean formulas \cite{TiD14}. In this section, bilinear maps are only defined, while next section presents a relationship between self-bilinear maps and multilinear maps. \\

\textbf{Definition 1} (Bilinear Map \cite{BCM16}). \textit{Given the cyclic groups $G$ and $G_t$ (written additively) of the same order $p$, a (symmetric) map $e:G \cart G \ra G_t$ is said to be bilinear if the following properties hold:
\begin{enumerate}
	\item \textbf{(Bi-linearity)}\space  $e({g_1}^{x_1}, {g_2}^{x_2}) = e(g_1,g_2)^{x_1x_2},$ for any $x_1,x_2 \in \bZ_p$ and any $g_1, g_2 \in G$;
	\item  \textbf{(Non-degeneracy)} \space If $g_1, g_2\in G$ are generators of $G$, then $e(g_1, g_2)$ is a generator of $G_t$;
	\item \textbf{(Efficient computability)} There exists a polynomially-bounded algorithm to compute $e(g_1,g_2)$, for any $g_1,g_2 \in G$.
\end{enumerate} 
}

\section{Cryptographic Multilinear Maps}
\textbf{Definition 2} (Multilinear Maps \cite{Rot13}). \textit{ Let $k \geq 2$ be an integer number and $G_1, G_2,...,G_k, G_T$ be $k + 1$ cyclic groups (written additively), of same order $p$. Then, a $k-$multilinear map is a mapping $e:G_1\cart...\cart G_k \ra G_T$, with the following properties:
	\begin{enumerate}
		\item \textbf{(Linearity)} For every $g_1\in G_1, ..., g_k \in G_k$, every $i\in \{1,2,..,k\}$ and every $\alpha\in \bZ_p$, it holds that:
\begin{align*}
			e(g_1,...,\alpha \cdot g_i, ..,g_k) = \alpha \cdot e(g_1,...,g_k))
\end{align*}
		\item \textbf{(Non-degeneracy)} If $g_1\in G_1, ..., g_k \in G_k$ are generators of their respective groups, then $e(g_1,...,g_k)$ is a generator of $G_T$.
	\end{enumerate}
}

\subsection{From Self-Bilinear to Multilinear Maps}

\textbf{Definition 3.} \textit{A self-bilinear map is a bilinear map where the domain and target groups are the same.} \\

\textbf{Proposition 1.} \textit{Let $G$ be a cyclic group of order $p$ and $e:G\cart G\ra G$ be a self-bilinear map. Therefore, a $k-$multilinear map $e_k:G^k \ra G$ can be constructed from $e$, for any $k \geq 2$.}\\

\textbf{\textit{Proof.}} The proof is realized by induction. First, for the base case $k = 2$, it is trivial to observe that $e$ itself is a 2-liniar map. Then, suppose that an $n-$multilinear map $e_n:G^n\ra G$ can be constructed starting from $e$, and it can be easily shown that a $(n+1)$-multilinear map $e_{n+1}:G^{n+1}\ra G$ can be constructed, as follows:
\begin{align*}
	e_{n+1}(g_1,..,g_n, g_{n+1}) = e(e_n(g_1,.., g_n), g_{n+1}), \forall g_1, .., g_{n+1} \in G.
\end{align*}
Indeed, from the fact that $e_n$ is multilinear it follows that, for any $g_1\in G_1, ..., g_n \in G_n$, any $i\in \{1,..,n\}$ and any $\alpha \in \bZ_p$,  $e_n(g_1,...,\alpha \cdot g_i, ..,g_n) = \alpha \cdot e_n(g_1,...,g_n))$. Using the bilinearity of $e$, it results that $e_{n+1}$ respects the \textbf{linearity} condition.\\
Let $g_1, ...,g_n$ be generators of $G$. Then, using the fact that $e_{n}$ is $n-$multilinear, it follows that $e_n(g_1,..,g_n)$ is also a generator of $G$. Corroborating the last result with the non-degeneracy property of $e$, it ensues that $e_{n+1}$ respects \textbf{non-degeneracy} condition, from which the conclusion that $e_{n+1}$ is a $(n+1)$-multilinear map can be drawn. \qed\\

However, Cheon and Lee \cite{ChL09} proved that self-bilinear maps on prime order groups do not exist, except that the computational Diffie-Hellman problem is easy. That is the main motivation of \cite{BCM16}, which analyzes the existence of self-bilinear maps on groups of composite order.

\subsection{Efficient Procedures}

In order to use the cryptographic multilinear applications in a real-world environment, efficient procedures must be designed, to be evaluated by computers. Therefore, as specified in \cite{GGH13}
a cryptographic multilinear map scheme is a 5-uple $\mathcal{MMP} = $ \textbf{(InstGen, EncTest, add, neg, map)} that is described below:
\begin{enumerate}[label=(\alph*)]
	\item \textbf{Instance Generation.}  A procedure with a "factory" role must exist, in order to instantiate the parameters of the scheme. This procedure is \textbf{InstGen}.
	\begin{itemize}
		\item \textbf{Input:} $\lambda $ - the security parameter and $k \geq 2$ - the multilinearity parameter.
		\item \textbf{Output:} (\textbf{params}, $g_1, .., g_k$), where \textbf{params} = ($G_1, .., G_T, p, e$). Here $G_1,..,G_k,$ $G_T$ represent the groups, $p\in \bZ$ is their order, $e$ is the representation of the multilinear map and $g_i \in \{0, 1\}^*$ is the representation of a generator of $G_i$, for every $i \in \{1,..,k\}$.
	\end{itemize}


	\item \textbf{Element Encoding.} A procedure that decides if a sequence of bits represents an encoding of an element in one of the groups must be defined, and it is named \textbf{EncTest}.
		\begin{itemize}
		\item \textbf{Input:} \textbf{params} - the instance parameters, $i \in \{1,..,k+1\}$ - index of the desired group and $x\in \{0,1\}^*$ - encoding of the tested element.
		\item \textbf{Output:} True, if $x$ is a valid encoding of an element in $G_i$, False otherwise. \textit{Note:} The extension $G_{k+1} = G_T$ is performed.
	\end{itemize}


	\item \textbf{Group addition.} The procedure \textbf{add} simply applies the group operation upon two provided elements representations.
\begin{itemize}
	\item \textbf{Input:} \textbf{params} - the instance parameters, $i \in \{1,..,k+1\}$ - index of the desired group, $x,y$ - representations of elements to be added.
	\item \textbf{Output:} the representation of $x+y \in G_i$.                                     
\end{itemize}


	\item \textbf{Group negation.} The procedure \textbf{neg} returns the inverse representation of the  element provided as parameter.
\begin{itemize}
	\item \textbf{Input:} \textbf{params} - the instance parameters, $i \in \{1,..,k+1\}$ - index of the desired group, $x$ - representation of the element to be negated.
	\item \textbf{Output:} the representation of $-x \in G_i$.                                     
\end{itemize}


	\item \textbf{Map computation.} The procedure \textbf{map} returns the representation of the multilinear mapping over the elements given as parameters.
\begin{itemize}
	\item \textbf{Input:} \textbf{params} - the instance parameters, $x_1\in G_1, .., x_k \in G_k$ - elements in domain groups.
	\item \textbf{Output:} the representation of $e(x_1,..,x_k) \in G_T$.
\end{itemize}
\end{enumerate}

\subsection{Hardness Assumptions}
For the multilinear map to be used in cryptography, it is inquired that at least the Multilinear Discrete Logarithm problem (MDL) and Multilinear Decisional Diffie-Hellman problem (MDDH) to be hard in the used groups. The specified problems are reminded below:

\begin{enumerate}
	\item \textbf{Multilinear Discrete Logarithm (MDL \cite{GGH13}).} It is said that the MDL problem is hard for a multilinear map scheme $\mathcal{MMP}$ if, for any $k > 1, $ any $i\in \{1,...,k\}$ and all probabilistic polynomial running time algorithms, the discrete logarithm advantage of an adversary $\mathcal{A}$,
	\begin{center}
		AdvDlog$_{\mathcal{MMP, A}, k}(\lambda) \stackrel{\mathclap{\normalfont\mbox{def}}}{=} Pr[\mathcal{A}(params, i, g_i, \alpha \cdot g_i) = \alpha : (params, g_1, ..., g_k) \la$ InstGen$(1^\lambda, 1^k), \alpha \la \bZ_p] $,
	\end{center}
	is negligible in $\lambda$.
	
	\item \textbf{Multilinear DDH (MDDH \cite{GGH13}).} The MDDH problem is hard for a symmetric multilinear map scheme $\mathcal{MMP}$ (with $G_1=..=G_k = G_T$) if for any probabilistic polynomial running time algorithm $\mathcal{A}$, the advantage of $\mathcal{A}$ in distinguishing between the distributions:
	
	\begin{center}
		$(params, g, \alpha_0g, \alpha_1g,..,\alpha_kg, (\displaystyle{\prod_{i=0}^{k}}\alpha_i)\cdot e(g,..,g))$ and \\
		$(params, g, \alpha_0g, \alpha_1g,..,\alpha_kg, \alpha \cdot e(g,..,g))$
	\end{center}
	is negligible in $\lambda$, where $(params, g)\la$ InstGen$(1^\lambda, 1^k)$ and $\alpha, \alpha_1, .., \alpha_k$ are uniformly random in $\bZ_p$.
\end{enumerate}


\section{Graded Encoding Systems}
Garg, Gentry and Halevi formally defined the Graded Encoding Systems in \cite{GGH13}. Using the mentioned system, the authors managed to realize an "approximation" of the sought after multilinear maps in groups in which the DL problem is hard. \\

They generalize the conventional constructions, by replacing the usual exponent space, $\bZ_p$, with a generic algebraic ring or field $R$. Also, the system is non-deterministic, with the significance that the same element can be encoded in plentiful of ways. Another difference is that the system offers the possibility of "partial mapping", i.e. multiplying any number of encodings, not only $k$, as in the multilinear map case. Thus, the structure of the system is much richer, revealing the opportunity to encode the same element on many different levels.\\

In the current section, the general settings of the system are discussed, following that the construction of an instance of Graded Encoding Systems (GES) to be approached in a subsequent chapter.\\

\textbf{Definition 4} ($k-$ Graded Encoding System). \textit{
	Let $k > 1$ be an integer. A $k-$ Graded Encoding System is formed by a ring $(R, +_R, \cdot_R)$ and a system of sets $\mathcal{S} = \{S_i^{(\alpha)}\subset \{0,1\}^*: \alpha \in R, i\in \{0,1,..,k\} \}$, with the properties:
	\begin{enumerate}
	\item For any $i\in \{0,1,..,k\}$, the sets $\{S_i^{(\alpha)}:\alpha \in R\}$ are disjoint;
	\item An associative binary operation '+' and an unary operation '-' can be defined on $\{0,1\}^*$, such that for any $\alpha_1, \alpha_2 \in R$, any $i \in \{0,..,k\}$ and any encodings $u_1\in S_i^{(\alpha_1)},$ $u_2\in S_i^{(\alpha_2)}$, it follows that $u_1 + u_2 \in S_i^{(\alpha_1 +_R \alpha_2)}$ and $-u_1\in S_i^{(-_R\alpha_1)}$;
	\item An associative binary operation '$\cart$' can be defined on $\{0,1\}^*$, such that for any $\alpha_1, \alpha_2 \in R$, any integers $0\leq i_1, i_2$ such that $i_1+i_2 \leq k$ and any encodings $u_1 \in S_{i_1}^{(\alpha_1)},$ $u_2 \in S_{i_2}^{(\alpha_2)}$, it results that $u_1\cart u_2 \in S_{i_1 +_R i_2}^{(\alpha_1 \cdot_R \alpha_2)}$.
\end{enumerate}
}

\subsection{Efficient Procedures}
\begin{enumerate}[label=(\alph*)]
	\item \textbf{Instance Generation.}	 Again, \textbf{InstGen} is a randomized procedure that has the task to instantiate the parameters of the scheme.
	\begin{itemize}
		\item \textbf{Input:} {\boldmath$\lambda$} - the security parameter and {\boldmath$k$} $\geq 2$ - the multilinearity parameter.
		\item \textbf{Output:} \textbf{InstGen}($1^\lambda, 1^k$) = (\textbf{params}, \pzt), where \textbf{params} completely specifies the $k-$GES, and {\pzt}  is a zero-test parameter, as described below.
	\end{itemize}

	\newpage
	\item \textbf{Ring Sampler.} \textbf{samp} is a non-deterministic procedure that returns a "level-zero" encoding of a nearly uniform element of $R$.
		\begin{itemize}
		\item \textbf{Input}: None
		\item \textbf{Output:} \textbf{samp}(\textbf{params}) = {\boldmath$a$} $\in S_0^{(\alpha)}$, with $\alpha\in R$ - nearly uniform.
	\end{itemize}

	\item \textbf{Encoding.} The procedure \textbf{enc} computes an encoding on any level of a given "level-zero" encoding.
	\begin{itemize}
		\item \textbf{Input}: \textbf{params} - the instance parameters, {\boldmath$i$} $\in \{0,..,k\}$ - the index of the desired level of encoding and {\boldmath$a$} $\in S_0^{(\alpha)}$ - the "level-zero" encoding of an element $\alpha \in R$.
		\item \textbf{Output:} \textbf{enc}(\textbf{params}, $i, a$) = {\boldmath$v$} $\in S_i^{(\alpha)}$ - a level$-i$ encoding of the same $\alpha$ previously specified.
	\end{itemize}

	\item \textbf{Addition.} The procedure \textbf{add} computes an encoding of the sum of two same-level encodings.
	\begin{itemize}
		\item \textbf{Input}: \textbf{params} - the instance parameters, {\boldmath$i$} $\in \{0,..,k\}$ - the index of the level of encoding, {\boldmath$v_1$} $\in S_i^{(\alpha_1)},$ {\boldmath$v_2$} $\in S_i^{(\alpha_2)}$ (where $\alpha_1, \alpha_2\in R$) - encodings of the elements to be added.
		\item \textbf{Output:} \textbf{add}(\textbf{params}, $i, v_1, v_2$) = {\boldmath$ v_1 + v_2$} $ \in S_i^{(\alpha_1 +_R \alpha_2)}$.
	\end{itemize}

	
	\item \textbf{Negation.} The procedure \textbf{neg} computes an encoding of the inverse of a provided element.
	\begin{itemize}
		\item \textbf{Input}: \textbf{params} - the instance parameters, {\boldmath$i$} $ \in \{0,..,k\}$ - the index of the level of encoding, {\boldmath$v$} $\in S_i^{(\alpha)}$ (where $\alpha\in R$) - an encoding of the element to be negated.
		\item \textbf{Output:} \textbf{neg}(\textbf{params}, $i, v$) = {\boldmath $-v $} $\in S_i^{(-_R\alpha)}$.
	\end{itemize}


	\item \textbf{Multiplication.} The procedure \textbf{mul} computes an encoding of the multiplication of two elements, which may be on different levels of encoding.
	\begin{itemize}
		\item \textbf{Input}: \textbf{params} - the instance parameters, $0 \leq$ {\boldmath$ i_1, i_2 $} - the indexes of the encoding levels of the elements (with $i_1 + i_2 \leq k$) , {\boldmath$u_1$} $ \in S_{i_1}^{(\alpha_1)},$ {\boldmath$ u_2$} $ \in S_{i_2}^{(\alpha_2)}$ - the encoding of the elements to be multiplied.
		\item \textbf{Output:} \textbf{mul}(params, $i_1,u_1,i_2,u_2$) = {\boldmath$u_1 \cart u_2$} $ \in S_{i_1+_R i_2}^{(\alpha_1 \cdot_R \alpha_2)}$.
	\end{itemize}

	\item \textbf{Zero-test.} The procedure \textbf{isZero} verifies if the given parameter is a "level-$k$" encoding of 0.
	\begin{itemize}
		\item \textbf{Input}: \textbf{params} - the instance parameters, {\boldmath$u$} - a "level-$k$" encoding of an element in $R$.
		\item \textbf{Output:} \textbf{isZero}(params, $u$) = \textbf{1}, if $u \in S_k^{(0)}$, \textbf{0} otherwise.
	\end{itemize}

	\item \textbf{Extraction.} The procedure \textbf{ext} realizes the "selection" of a unique "level-$k$" representative, for every ring element. Also, the elements returned are almost random over $\{0, 1\}^\lambda$.
	\begin{itemize}
		\item \textbf{Input}: \textbf{params} - the instance parameters, {\pzt} - the zero-test parameter, {\boldmath$u$} - the "level$-k$" encoding of a ring element.
		\item \textbf{Output:} \textbf{ext}(params, {\pzt}, $u$) = {\boldmath$s$} $\in \{0,1\}^\lambda$, such that:
		\begin{enumerate}[label=(\roman*)]
			\item $\forall \alpha \in R, v_1,v_2\in S_k^{(\alpha)}$, it holds that \textbf{ext}(params, {\pzt}, $v_1$) = \textbf{ext}(params, {\pzt}, $v_2$);
			\item The distribution \{\textbf{ext}(params, {\pzt}, $v$) : $\alpha \in R, v \in S_k^{(\alpha)}$\} is nearly uniform over $\{0,1\}^\lambda$.
		\end{enumerate}
	\end{itemize}
	
	
\end{enumerate}

\textbf{Remark 1.} \textit{In practice, due to the limitations of computers, the zero-test and the extraction procedures requirements are lessened. Therefore, the zero-test procedure may output 1 for encodings of non-zero elements, with negligible probability in $\lambda$. Also, the extraction procedure may output different "level-$k$" representatives of the same ring element, again with negligible probability in $\lambda$}.\\

\textbf{Remark 2.} \textit{To test if two elements, $u, v\in S_k$, encode the same element $\alpha \in R$, it is sufficient to verify if \textbf{isZero}(params, \textbf{add}(params, $k, u$, \textbf{neg}(params, $k, v$)))) returns 1, i.e. $u - v \in S_k^{(0)}$.}

\subsection{Hardness Assumptions}

dsa dadas
